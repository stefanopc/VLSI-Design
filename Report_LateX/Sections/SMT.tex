\section{SMT}

Another approach to this problem consists in using SMT (Satisfiability Modulo Theories) that was chosen because of its expressive power due to first-order logic compared to SAT, which instead can be complex to formalize. The main drawback of SMT models is the worse efficiency, which however is compensated by the higher expressivity and scalability.

\subsection{Variables}

Modeling with SMT followed the same scheme that was seen for CP.
First, the coordinates of the circuits have been encoded into two vectors $x$ and $y$ of integers with dimension given by the number of circuits.
As previously seen, the arrays $x\_sizes$ and $y\_sizes$ contain the widths and heights of all the circuits, while $height$ represents the maximum height of the plate and it is the objective function to minimize.
The optimizer is called with the function \verb|Optimize()| given by Z3 solver, whose aim is to minimize the objective function \textit{height}.

As done before, the variable domain has been reduced to speed up the search: first of all, the horizontal coordinates $x_i$ have to be greater than zero and their sum with the circuit widths must be below the plate width.

\begin{equation*}
    \forall i \in {1..n} \quad x_i \geq 0 \; \land x_i + x\_sizes_i \leq w
\end{equation*}

Similarly, the vertical coordinates $y_i$ have to be greater than zero and their sum with the circuit heights must be below the maximum plate height.

\begin{equation*}
     \forall i \in {1..n} \quad y_i \geq 0 \; \land y_i + y\_sizes_i \leq height
\end{equation*}

\subsection{Constraints}

The main constraints are meant to tell the solver to respect the boundaries of the plate for the horizontal and vertical coordinates:

\begin{equation*}
     \forall i \in {1..n} \quad x_i + x\_sizes_i \leq w
\end{equation*}

\begin{equation*}
     \forall i \in {1..n} \quad y_i + y\_sizes_i \leq height
\end{equation*}

Furthermore, a similar definition of the global constraint \textit{cumulative} (previously used in Minizinc for the CP solution) was given. Our problem was seen as a resource usage task where each circuit is an activity whose duration is the vertical height, its resources is equal to its
horizontal width and the total number of resources is the plate width w. The same reasoning can be applied to the other axis.

This is defined in the following way:
\begin{gather*}
cumulative(y, y\_sizes, x\_sizes, width) \\
cumulative(x, x\_sizes, y\_sizes, height_{max})
\end{gather*}

Moreover, a non-overlapping constraint is necessary to make sure that no pair of rectangles overlap:

\begin{multiline}
     \forall i,j \in {1..n}, i \neq j \quad x_i + x\_sizes_i \leq x_j \lor x_j + x\_sizes_j \leq x_i \lor y_i + y\_sizes_i \leq y_i \lor y_i + y_j + y\_sizes_j \leq y_i
\end{multiline}

Symmetry braking constraints are the same as in CP: it has been decided to put the biggest circuit in the bottom left part of the plate, at x and y coordinates equal to zero.

\subsection{Rotation model}

If we allow the rotation of the circuits, we need to perform some modification to the model: we introduce two other vectors of variables $x\_sizes\_rot$ and $y\_sizes\_rot$ which contain the actual widths and heights considered, since in case of rotation the values of width and height will be swapped. 
\begin{gather*}
     \forall i \in {1..n} \quad (x\_sizes\_rot_i = x\_sizes_i \; \land \; y\_sizes\_rot_i = y\_sizes_i) \; \lor \; \\
     \lor \; (x\_sizes\_rot_i = y\_sizes_i \land y\_sizes\_rot_i = x\_sizes_i)
\end{gather*}
It is also necessary to add another symmetry braking constraint due to the fact that, in case of rectangles which are squares (where width is equal to height), the solver will consider identical the solutions where it is rotated and where it is not rotated. With this constraint we force width and height to be the original ones, hence avoiding a possible rotation.

\begin{equation*}
     \forall i \in {1..n} \quad x\_sizes_i = y\_sizes_i \implies (x\_sizes\_rot_i = x\_sizes_i \land y\_sizes\_rot_i = y\_sizes_i)
\end{equation*}

As previously done, the output file is modified to print the string \textit{"rotated"} in case a circuit is rotated. 

\subsection{Search}

The standard search method provided by Z3Py was used to compare the performance of the models: the class \verb|Optimize| allows to get an assignment for each variable which minimizes the objective function through the method \verb|Optimize.minimize(<minimization objective>)|, hence it is applicable to our problem where we want to minimize \textit{height}.

\subsection{Results}

\begin{center}
\begin{longtable}{|l|l|l|}
\caption{Solving times obtained by SMT models (without and with rotation)} \label{tab:long} \\

\hline \multicolumn{1}{|c|}{\textbf{Instance}} & \multicolumn{1}{c|}{\textbf{No rotation}} & \multicolumn{1}{c|}{\textbf{Rotation}} \\ \hline 
\endfirsthead

\multicolumn{3}{c}%
{{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
\hline \multicolumn{1}{|c|}{\textbf{Instance}} & \multicolumn{1}{c|}{\textbf{No rotation}} & \multicolumn{1}{c|}{\textbf{Rotation}} \\ \hline 
\endhead

\hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline
\endfoot

\hline \hline
\endlastfoot

1 & 0,005 & 0,018 \\
2 & 0,010 & 0,049 \\
3 & 0,014 & 0,090 \\
4 & 0,025 & 0,308 \\
5 & 0,041 & 0,859 \\
6 & 0,063 & 0,592 \\
7 & 0,078 & 0,889 \\
8 & 0,095 & 1,453 \\
9 & 0,109 & 1,249 \\
10 & 0,339 & 53,28 \\
11 & - & - \\
12 & 0,615 & 82,80 \\
13 & 0,890 & 48,83 \\
14 & 2,218 & 127,5 \\
15 & 1,444 & 77,81 \\
16 & - & - \\
17 & 6,597 & 27,88 \\
18 & 10,02 & - \\
19 & - & - \\
20 & 20,50 & - \\
21 & - & - \\
22 & - & - \\
23 & 14,08 & - \\
24 & 0,621 & - \\
25 & - & - \\
26 & 169,9 & - \\
27 & 39,64 & - \\
28 & 33,83 & - \\
29 & 43,54 & - \\
30 & - & - \\
31 & 18,178 & - \\
32 & - & - \\
33 & 17,81 & - \\
34 & - & - \\
35 & - & - \\
36 & - & - \\
37 & - & - \\
38 & - & - \\
39 & - & - \\
40 & - & - \\
\end{longtable}
\end{center}